import Schema from "../schema/schema";
import Client from "../client";
import Entity from "../entity/entity";
import { Search, RawSearch } from '../search/search';
import EntityData from "../entity/entity-data";
/**
 * A repository is the main interaction point for reading, writing, and
 * removing {@link Entity | Entities} from Redis. Create one by calling
 * {@link Client.fetchRepository} and passing in a {@link Schema}. Then
 * use the {@link Repository.fetch}, {@link Repository.save}, and
 * {@link Repository.remove} methods to manage your data:
 *
 * ```typescript
 * const repository = client.fetchRepository<Foo>(schema);
 *
 * const foo = await repository.fetch('01FK6TCJBDK41RJ766A4SBWDJ9');
 * foo.aString = 'bar';
 * foo.aBoolean = false;
 * await repository.save(foo);
 * ```
 *
 * Be sure to use the repository to create a new instance of an
 * {@link Entity} you want to create before you save it:

 * ```typescript
 * const foo = await repository.createEntity();
 * foo.aString = 'bar';
 * foo.aBoolean = false;
 * await repository.save(foo);
 * ```
 *
 * If you want to the {@link Repository.search} method, you need to create an index
 * first, and you need RediSearch or RedisJSON installed on your instance of Redis:
 *
 * ```typescript
 * await repository.createIndex();
 * const entities = await repository.search()
 *   .where('aString').eq('bar')
 *   .and('aBoolean').is.false().returnAll();
 * ```
 *
 * @template TEntity The type of {@link Entity} that this repository manages.
 */
export default abstract class Repository<TEntity extends Entity> {
    protected client: Client;
    protected schema: Schema<TEntity>;
    /** @internal */
    constructor(schema: Schema<TEntity>, client: Client);
    /**
     * Creates an index in Redis for use by the {@link Repository.search} method. Requires
     * that RediSearch or RedisJSON is installed on your instance of Redis.
     */
    createIndex(): Promise<void>;
    /**
     * Removes an existing index from Redis. Use this method if you want to swap out your index
     * because your {@link Entity} has changed. Requires that RediSearch or RedisJSON is installed
     * on your instance of Redis.
     */
    dropIndex(): Promise<void>;
    /**
     * Creates an {@link Entity} with a populated {@link Entity.entityId} property.
     * @param data Optional values with which to initialize the entity.
     * @returns A newly created Entity.
     */
    createEntity(data?: EntityData): TEntity;
    /**
     * Save the {@link Entity} to Redis. If it already exists, it will be updated. If it doesn't
     * exist, it will be created.
     * @param entity The Entity to save.
     * @returns The ID of the Entity just saved.
     */
    save(entity: TEntity): Promise<string>;
    /**
     * Creates and saves an {@link Entity}. Equivalent of calling
     * {@link Repository.createEntity} followed by {@link Repository.save}.
     * @param data Optional values with which to initialize the entity.
     * @returns The newly created and saved Entity.
     */
    createAndSave(data?: EntityData): Promise<TEntity>;
    /**
     * Read and return an {@link Entity} from Redis with the given id. If
     * the {@link Entity} is not found, returns an {@link Entity} with all
     * properties set to `null`.
     * @param id The ID of the {@link Entity} you seek.
     * @returns The matching Entity.
     */
    fetch(id: string): Promise<TEntity>;
    /**
     * Read and return the {@link Entity | Entities} from Redis with the given IDs. If
     * a particular {@link Entity} is not found, returns an {@link Entity} with all
     * properties set to `null`.
     * @param ids The IDs of the {@link Entity | Entities} you seek.
     * @returns The matching Entities.
     */
    fetchMany(...ids: string[]): Promise<TEntity[]>;
    /**
     * Remove an {@link Entity} from Redis with the given id. If the {@link Entity} is
     * not found, does nothing.
     * @param id The ID of the {@link Entity} you with to delete.
     */
    remove(...ids: string[]): Promise<void>;
    /**
     * Set the time to live of the {@link Entity}. If the {@link Entity} is not
     * found, does nothing.
     * @param id The ID of the {@link Entity} to set and expiration for.
     * @param ttlInSeconds THe time to live in seconds.
     */
    expire(id: string, ttlInSeconds: number): Promise<void>;
    /**
     * Kicks off the process of building a query. Requires that RediSearch (and optionally
     * RedisJSON) be is installed on your instance of Redis.
     * @template TEntity The type of {@link Entity} sought.
     * @returns A {@link Search} object.
     */
    search(): Search<TEntity>;
    /**
     * Creates a search that bypassed Redis OM and instead allows you to execute a raw
     * RediSearch query. Requires that RediSearch (and optionally RedisJSON) be installed
     * on your instance of Redis.
     * @template TEntity The type of {@link Entity} sought.
     * @query The raw RediSearch query you want to rune.
     * @returns A {@link RawSearch} object.
     */
    searchRaw(query: string): RawSearch<TEntity>;
    /** @internal */
    protected abstract writeEntity(entity: TEntity): Promise<void>;
    /** @internal */
    protected abstract readEntities(ids: string[]): Promise<TEntity[]>;
    /** @internal */
    protected makeKeys(ids: string[]): string[];
    /** @internal */
    protected makeKey(id: string): string;
}
/** @internal */
export declare class HashRepository<TEntity extends Entity> extends Repository<TEntity> {
    protected writeEntity(entity: TEntity): Promise<void>;
    protected readEntities(ids: string[]): Promise<TEntity[]>;
}
/** @internal */
export declare class JsonRepository<TEntity extends Entity> extends Repository<TEntity> {
    protected writeEntity(entity: TEntity): Promise<void>;
    protected readEntities(ids: string[]): Promise<TEntity[]>;
}
