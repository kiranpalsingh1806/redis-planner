"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Search = exports.RawSearch = exports.AbstractSearch = void 0;
const tslib_1 = require("tslib");
const logger = tslib_1.__importStar(require("../shims/logger"));
const where_and_1 = tslib_1.__importDefault(require("./where-and"));
const where_or_1 = tslib_1.__importDefault(require("./where-or"));
const where_string_array_1 = tslib_1.__importDefault(require("./where-string-array"));
const where_boolean_1 = require("./where-boolean");
const where_number_1 = tslib_1.__importDefault(require("./where-number"));
const where_point_1 = tslib_1.__importDefault(require("./where-point"));
const where_string_1 = tslib_1.__importDefault(require("./where-string"));
const where_text_1 = tslib_1.__importDefault(require("./where-text"));
const results_converter_1 = require("./results-converter");
const __1 = require("..");
const where_date_1 = tslib_1.__importDefault(require("./where-date"));
/**
 * Abstract base class for {@link Search} and {@link RawSearch} that
 * contains methods to return search results.
 * @template TEntity The type of {@link Entity} being sought.
 */
class AbstractSearch {
    /** @internal */
    schema;
    /** @internal */
    client;
    /** @internal */
    sort;
    /** @internal */
    constructor(schema, client) {
        this.schema = schema;
        this.client = client;
    }
    /**
     * Applies an ascending sort to the query.
     * @param field The field to sort by.
     * @returns this
     */
    sortAscending(field) {
        return this.sortBy(field, 'ASC');
    }
    /**
     * Alias for {@link Search.sortDescending}.
     */
    sortDesc(field) {
        return this.sortDescending(field);
    }
    /**
     * Applies a descending sort to the query.
     * @param field The field to sort by.
     * @returns this
     */
    sortDescending(field) {
        return this.sortBy(field, 'DESC');
    }
    /**
     * Alias for {@link Search.sortAscending}.
     */
    sortAsc(field) {
        return this.sortAscending(field);
    }
    /**
       * Applies sorting for the query.
       * @param field The field to sort by.
       * @param order The order of returned {@link Entity | Entities} Defaults to `ASC` (ascending) if not specified
       * @returns this
       */
    sortBy(field, order = 'ASC') {
        const fieldDef = this.schema.definition[field];
        const dataStructure = this.schema.dataStructure;
        if (fieldDef === undefined) {
            const message = `'sortBy' was called on field '${field}' which is not defined in the Schema.`;
            logger.error(message);
            throw new __1.RedisError(message);
        }
        const type = fieldDef.type;
        const markedSortable = fieldDef.sortable;
        const UNSORTABLE = ['point', 'string[]'];
        const JSON_SORTABLE = ['number', 'text', 'date'];
        const HASH_SORTABLE = ['string', 'boolean', 'number', 'text', 'date'];
        if (UNSORTABLE.includes(type)) {
            const message = `'sortBy' was called on '${type}' field '${field}' which cannot be sorted.`;
            logger.error(message);
            throw new __1.RedisError(message);
        }
        if (dataStructure === 'JSON' && JSON_SORTABLE.includes(type) && !markedSortable)
            logger.warn(`'sortBy' was called on field '${field}' which is not marked as sortable in the Schema. This may result is slower searches. If possible, mark the field as sortable in the Schema.`);
        if (dataStructure === 'HASH' && HASH_SORTABLE.includes(type) && !markedSortable)
            logger.warn(`'sortBy' was called on field '${field}' which is not marked as sortable in the Schema. This may result is slower searches. If possible, mark the field as sortable in the Schema.`);
        this.sort = { field, order };
        return this;
    }
    /**
     * Finds the {@link Entity} with the minimal value for a field.
     * @param field The field with the minimal value.
     * @returns The {@link Entity} with the minimal value
     */
    async min(field) {
        return await this.sortBy(field, 'ASC').first();
    }
    /**
     * Finds the entity ID with the minimal value for a field.
     * @param field The field with the minimal value.
     * @returns The entity ID with the minimal value
     */
    async minId(field) {
        const key = await this.minKey(field);
        return this.keyToEntityId(key);
    }
    /**
     * Finds the key name in Redis with the minimal value for a field.
     * @param field The field with the minimal value.
     * @returns The key name with the minimal value
     */
    async minKey(field) {
        return await this.sortBy(field, 'ASC').firstKey();
    }
    /**
     * Finds the {@link Entity} with the maximal value for a field.
     * @param field The field with the maximal value.
     * @returns The entity ID {@link Entity} with the maximal value
     */
    async max(field) {
        return await this.sortBy(field, 'DESC').first();
    }
    /**
     * Finds the entity ID with the maximal value for a field.
     * @param field The field with the maximal value.
     * @returns The entity ID with the maximal value
     */
    async maxId(field) {
        const key = await this.maxKey(field);
        return this.keyToEntityId(key);
    }
    /**
     * Finds the key name in Redis with the maximal value for a field.
     * @param field The field with the maximal value.
     * @returns The key name with the maximal value
     */
    async maxKey(field) {
        return await this.sortBy(field, 'DESC').firstKey();
    }
    /**
     * Returns the number of {@link Entity | Entities} that match this query.
     * @returns
     */
    async count() {
        const searchResults = await this.callSearch();
        return this.schema.dataStructure === 'JSON'
            ? new results_converter_1.JsonSearchResultsConverter(this.schema, searchResults).count
            : new results_converter_1.HashSearchResultsConverter(this.schema, searchResults).count;
    }
    /**
     * Returns a page of {@link Entity | Entities} that match this query.
     * @param offset The offset for where to start returning {@link Entity | Entities}.
     * @param count The number of {@link Entity | Entities} to return.
     * @returns An array of {@link Entity | Entities} matching the query.
     */
    async page(offset, count) {
        const searchResults = await this.callSearch({ offset, count });
        return this.schema.dataStructure === 'JSON'
            ? new results_converter_1.JsonSearchResultsConverter(this.schema, searchResults).entities
            : new results_converter_1.HashSearchResultsConverter(this.schema, searchResults).entities;
    }
    /**
     * Returns a page of entity IDs that match this query.
     * @param offset The offset for where to start returning entity IDs.
     * @param count The number of entity IDs to return.
     * @returns An array of strings matching the query.
     */
    async pageOfIds(offset, count) {
        const keys = await this.pageOfKeys(offset, count);
        return this.keysToEntityIds(keys);
    }
    /**
     * Returns a page of key names in Redis that match this query.
     * @param offset The offset for where to start returning key names.
     * @param count The number of key names to return.
     * @returns An array of strings matching the query.
     */
    async pageOfKeys(offset, count) {
        const [_count, ...keys] = await this.callSearch({ offset, count }, true);
        return keys;
    }
    /**
     * Returns the first {@link Entity} that matches this query.
     */
    async first() {
        const foundEntity = await this.page(0, 1);
        return foundEntity[0] ?? null;
    }
    /**
     * Returns the first entity ID that matches this query.
     */
    async firstId() {
        const key = await this.firstKey();
        return this.keyToEntityId(key);
    }
    /**
     * Returns the first key nameÂ that matches this query.
     */
    async firstKey() {
        const foundIds = await this.pageOfKeys(0, 1);
        return foundIds[0] ?? null;
    }
    /**
     * Returns all the {@link Entity | Entities} that match this query. This method
     * makes multiple calls to Redis until all the {@link Entity | Entities} are returned.
     * You can specify the batch size by setting the `pageSize` property on the
     * options:
     *
     * ```typescript
     * const entities = await repository.search().returnAll({ pageSize: 100 });
     * ```
     *
     * @param options Options for the call.
     * @param options.pageSize Number of {@link Entity | Entities} returned per batch.
     * @returns An array of {@link Entity | Entities} matching the query.
     */
    async all(options = { pageSize: 10 }) {
        const entities = [];
        let offset = 0;
        const pageSize = options.pageSize;
        while (true) {
            const foundEntities = await this.page(offset, pageSize);
            entities.push(...foundEntities);
            if (foundEntities.length < pageSize)
                break;
            offset += pageSize;
        }
        return entities;
    }
    /**
     * Returns all the entity IDs that match this query. This method
     * makes multiple calls to Redis until all the entity IDs are returned.
     * You can specify the batch size by setting the `pageSize` property on the
     * options:
     *
     * ```typescript
     * const keys = await repository.search().returnAllIds({ pageSize: 100 });
     * ```
     *
     * @param options Options for the call.
     * @param options.pageSize Number of entity IDs returned per batch.
     * @returns An array of entity IDs matching the query.
     */
    async allIds(options = { pageSize: 10 }) {
        const keys = await this.allKeys(options);
        return this.keysToEntityIds(keys);
    }
    /**
     * Returns all the key names in Redis that match this query. This method
     * makes multiple calls to Redis until all the key names are returned.
     * You can specify the batch size by setting the `pageSize` property on the
     * options:
     *
     * ```typescript
     * const keys = await repository.search().returnAllKeys({ pageSize: 100 });
     * ```
     *
     * @param options Options for the call.
     * @param options.pageSize Number of key names returned per batch.
     * @returns An array of key names matching the query.
     */
    async allKeys(options = { pageSize: 10 }) {
        const keys = [];
        let offset = 0;
        const pageSize = options.pageSize;
        while (true) {
            const foundKeys = await this.pageOfKeys(offset, pageSize);
            keys.push(...foundKeys);
            if (foundKeys.length < pageSize)
                break;
            offset += pageSize;
        }
        return keys;
    }
    /**
     * Returns the current instance. Syntactic sugar to make your code more fluent.
     * @returns this
     */
    get return() {
        return this;
    }
    /**
     * Alias for {@link Search.min}.
     */
    async returnMin(field) {
        return await this.min(field);
    }
    /**
     * Alias for {@link Search.minId}.
     */
    async returnMinId(field) {
        return await this.minId(field);
    }
    /**
     * Alias for {@link Search.minKey}.
     */
    async returnMinKey(field) {
        return await this.minKey(field);
    }
    /**
     * Alias for {@link Search.max}.
     */
    async returnMax(field) {
        return await this.max(field);
    }
    /**
     * Alias for {@link Search.maxId}.
     */
    async returnMaxId(field) {
        return await this.maxId(field);
    }
    /**
     * Alias for {@link Search.maxKey}.
     */
    async returnMaxKey(field) {
        return await this.maxKey(field);
    }
    /**
     * Alias for {@link Search.count}.
     */
    async returnCount() {
        return await this.count();
    }
    /**
     * Alias for {@link Search.page}.
     */
    async returnPage(offset, count) {
        return await this.page(offset, count);
    }
    /**
     * Alias for {@link Search.pageOfIds}.
     */
    async returnPageOfIds(offset, count) {
        return await this.pageOfIds(offset, count);
    }
    /**
     * Alias for {@link Search.pageOrKeys}.
     */
    async returnPageOfKeys(offset, count) {
        return await this.pageOfKeys(offset, count);
    }
    /**
     * Alias for {@link Search.first}.
     */
    async returnFirst() {
        return await this.first();
    }
    /**
     * Alias for {@link Search.firstId}.
     */
    async returnFirstId() {
        return await this.firstId();
    }
    /**
     * Alias for {@link Search.firstKey}.
     */
    async returnFirstKey() {
        return await this.firstKey();
    }
    /**
     * Alias for {@link Search.all}.
     */
    async returnAll(options = { pageSize: 10 }) {
        return await this.all(options);
    }
    /**
     * Alias for {@link Search.allIds}.
     */
    async returnAllIds(options = { pageSize: 10 }) {
        return await this.allIds(options);
    }
    /**
     * Alias for {@link Search.allKeys}.
     */
    async returnAllKeys(options = { pageSize: 10 }) {
        return await this.allKeys(options);
    }
    async callSearch(limit = { offset: 0, count: 0 }, keysOnly = false) {
        const options = {
            indexName: this.schema.indexName,
            query: this.query,
            limit,
            keysOnly
        };
        if (this.sort !== undefined)
            options.sort = this.sort;
        let searchResults;
        try {
            searchResults = await this.client.search(options);
        }
        catch (error) {
            const message = error.message;
            if (message.startsWith("Syntax error")) {
                throw new __1.RedisError(`The query to RediSearch had a syntax error: "${message}".\nThis is often the result of using a stop word in the query. Either change the query to not use a stop word or change the stop words in the schema definition. You can check the RediSearch source for the default stop words at: https://github.com/RediSearch/RediSearch/blob/master/src/stopwords.h.`);
            }
            throw error;
        }
        return searchResults;
    }
    keysToEntityIds(keys) {
        return keys.map(key => this.keyToEntityId(key) ?? '');
    }
    keyToEntityId(key) {
        return key ? key.replace(`${this.schema.prefix}:`, '') : null;
    }
}
exports.AbstractSearch = AbstractSearch;
/**
 * Entry point to raw search which allows using raw RediSearch queries
 * against Redis OM. Requires that RediSearch (and optionally RedisJSON) be
 * installed.
 * @template TEntity The type of {@link Entity} being sought.
 */
class RawSearch extends AbstractSearch {
    rawQuery;
    /** @internal */
    constructor(schema, client, query = '*') {
        super(schema, client);
        this.rawQuery = query;
    }
    /** @internal */
    get query() {
        return this.rawQuery;
    }
}
exports.RawSearch = RawSearch;
/**
 * Entry point to fluent search. This is the default Redis OM experience.
 * Requires that RediSearch (and optionally RedisJSON) be installed.
 * @template TEntity The type of {@link Entity} being sought.
 */
class Search extends AbstractSearch {
    rootWhere;
    /** @internal */
    get query() {
        if (this.rootWhere === undefined)
            return '*';
        return `${this.rootWhere.toString()}`;
    }
    where(fieldOrFn) {
        return this.anyWhere(where_and_1.default, fieldOrFn);
    }
    and(fieldOrFn) {
        return this.anyWhere(where_and_1.default, fieldOrFn);
    }
    or(fieldOrFn) {
        return this.anyWhere(where_or_1.default, fieldOrFn);
    }
    anyWhere(ctor, fieldOrFn) {
        if (typeof fieldOrFn === 'string') {
            return this.anyWhereForField(ctor, fieldOrFn);
        }
        else {
            return this.anyWhereForFunction(ctor, fieldOrFn);
        }
    }
    anyWhereForField(ctor, field) {
        const where = this.createWhere(field);
        if (this.rootWhere === undefined) {
            this.rootWhere = where;
        }
        else {
            this.rootWhere = new ctor(this.rootWhere, where);
        }
        return where;
    }
    anyWhereForFunction(ctor, subSearchFn) {
        const search = new Search(this.schema, this.client);
        const subSearch = subSearchFn(search);
        if (subSearch.rootWhere === undefined) {
            throw new Error("Sub-search without and root where was somehow defined.");
        }
        else {
            if (this.rootWhere === undefined) {
                this.rootWhere = subSearch.rootWhere;
            }
            else {
                this.rootWhere = new ctor(this.rootWhere, subSearch.rootWhere);
            }
        }
        return this;
    }
    createWhere(field) {
        const fieldDef = this.schema.definition[field];
        if (fieldDef === undefined)
            throw new Error(`The field '${field}' is not part of the schema.`);
        if (fieldDef.type === 'boolean' && this.schema.dataStructure === 'HASH')
            return new where_boolean_1.WhereHashBoolean(this, field);
        if (fieldDef.type === 'boolean' && this.schema.dataStructure === 'JSON')
            return new where_boolean_1.WhereJsonBoolean(this, field);
        if (fieldDef.type === 'date')
            return new where_date_1.default(this, field);
        if (fieldDef.type === 'number')
            return new where_number_1.default(this, field);
        if (fieldDef.type === 'point')
            return new where_point_1.default(this, field);
        if (fieldDef.type === 'text')
            return new where_text_1.default(this, field);
        if (fieldDef.type === 'string')
            return new where_string_1.default(this, field);
        if (fieldDef.type === 'string[]')
            return new where_string_array_1.default(this, field);
        // @ts-ignore: This is a trap for JavaScript
        throw new Error(`The field type of '${fieldDef.type}' is not a valid field type. Valid types include 'boolean', 'date', 'number', 'point', 'string', and 'string[]'.`);
    }
}
exports.Search = Search;
