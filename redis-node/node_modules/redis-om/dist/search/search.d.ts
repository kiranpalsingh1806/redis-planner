import Schema from "../schema/schema";
import Client from "../client";
import Entity from '../entity/entity';
import WhereField from './where-field';
import { SortOptions } from "../client";
/**
 * A function that takes a {@link Search} and returns a {@link Search}. Used in nested queries.
 * @template TEntity The type of {@link Entity} being sought.
 */
export declare type SubSearchFunction<TEntity extends Entity> = (search: Search<TEntity>) => Search<TEntity>;
/**
 * Abstract base class for {@link Search} and {@link RawSearch} that
 * contains methods to return search results.
 * @template TEntity The type of {@link Entity} being sought.
 */
export declare abstract class AbstractSearch<TEntity extends Entity> {
    /** @internal */
    protected schema: Schema<TEntity>;
    /** @internal */
    protected client: Client;
    /** @internal */
    protected sort?: SortOptions;
    /** @internal */
    constructor(schema: Schema<TEntity>, client: Client);
    /** @internal */
    abstract get query(): string;
    /**
     * Applies an ascending sort to the query.
     * @param field The field to sort by.
     * @returns this
     */
    sortAscending(field: string): AbstractSearch<TEntity>;
    /**
     * Alias for {@link Search.sortDescending}.
     */
    sortDesc(field: string): AbstractSearch<TEntity>;
    /**
     * Applies a descending sort to the query.
     * @param field The field to sort by.
     * @returns this
     */
    sortDescending(field: string): AbstractSearch<TEntity>;
    /**
     * Alias for {@link Search.sortAscending}.
     */
    sortAsc(field: string): AbstractSearch<TEntity>;
    /**
       * Applies sorting for the query.
       * @param field The field to sort by.
       * @param order The order of returned {@link Entity | Entities} Defaults to `ASC` (ascending) if not specified
       * @returns this
       */
    sortBy(field: string, order?: 'ASC' | 'DESC'): AbstractSearch<TEntity>;
    /**
     * Finds the {@link Entity} with the minimal value for a field.
     * @param field The field with the minimal value.
     * @returns The {@link Entity} with the minimal value
     */
    min(field: string): Promise<TEntity | null>;
    /**
     * Finds the entity ID with the minimal value for a field.
     * @param field The field with the minimal value.
     * @returns The entity ID with the minimal value
     */
    minId(field: string): Promise<string | null>;
    /**
     * Finds the key name in Redis with the minimal value for a field.
     * @param field The field with the minimal value.
     * @returns The key name with the minimal value
     */
    minKey(field: string): Promise<string | null>;
    /**
     * Finds the {@link Entity} with the maximal value for a field.
     * @param field The field with the maximal value.
     * @returns The entity ID {@link Entity} with the maximal value
     */
    max(field: string): Promise<TEntity | null>;
    /**
     * Finds the entity ID with the maximal value for a field.
     * @param field The field with the maximal value.
     * @returns The entity ID with the maximal value
     */
    maxId(field: string): Promise<string | null>;
    /**
     * Finds the key name in Redis with the maximal value for a field.
     * @param field The field with the maximal value.
     * @returns The key name with the maximal value
     */
    maxKey(field: string): Promise<string | null>;
    /**
     * Returns the number of {@link Entity | Entities} that match this query.
     * @returns
     */
    count(): Promise<number>;
    /**
     * Returns a page of {@link Entity | Entities} that match this query.
     * @param offset The offset for where to start returning {@link Entity | Entities}.
     * @param count The number of {@link Entity | Entities} to return.
     * @returns An array of {@link Entity | Entities} matching the query.
     */
    page(offset: number, count: number): Promise<TEntity[]>;
    /**
     * Returns a page of entity IDs that match this query.
     * @param offset The offset for where to start returning entity IDs.
     * @param count The number of entity IDs to return.
     * @returns An array of strings matching the query.
     */
    pageOfIds(offset: number, count: number): Promise<string[]>;
    /**
     * Returns a page of key names in Redis that match this query.
     * @param offset The offset for where to start returning key names.
     * @param count The number of key names to return.
     * @returns An array of strings matching the query.
     */
    pageOfKeys(offset: number, count: number): Promise<string[]>;
    /**
     * Returns the first {@link Entity} that matches this query.
     */
    first(): Promise<TEntity | null>;
    /**
     * Returns the first entity ID that matches this query.
     */
    firstId(): Promise<string | null>;
    /**
     * Returns the first key nameÂ that matches this query.
     */
    firstKey(): Promise<string | null>;
    /**
     * Returns all the {@link Entity | Entities} that match this query. This method
     * makes multiple calls to Redis until all the {@link Entity | Entities} are returned.
     * You can specify the batch size by setting the `pageSize` property on the
     * options:
     *
     * ```typescript
     * const entities = await repository.search().returnAll({ pageSize: 100 });
     * ```
     *
     * @param options Options for the call.
     * @param options.pageSize Number of {@link Entity | Entities} returned per batch.
     * @returns An array of {@link Entity | Entities} matching the query.
     */
    all(options?: {
        pageSize: number;
    }): Promise<TEntity[]>;
    /**
     * Returns all the entity IDs that match this query. This method
     * makes multiple calls to Redis until all the entity IDs are returned.
     * You can specify the batch size by setting the `pageSize` property on the
     * options:
     *
     * ```typescript
     * const keys = await repository.search().returnAllIds({ pageSize: 100 });
     * ```
     *
     * @param options Options for the call.
     * @param options.pageSize Number of entity IDs returned per batch.
     * @returns An array of entity IDs matching the query.
     */
    allIds(options?: {
        pageSize: number;
    }): Promise<string[]>;
    /**
     * Returns all the key names in Redis that match this query. This method
     * makes multiple calls to Redis until all the key names are returned.
     * You can specify the batch size by setting the `pageSize` property on the
     * options:
     *
     * ```typescript
     * const keys = await repository.search().returnAllKeys({ pageSize: 100 });
     * ```
     *
     * @param options Options for the call.
     * @param options.pageSize Number of key names returned per batch.
     * @returns An array of key names matching the query.
     */
    allKeys(options?: {
        pageSize: number;
    }): Promise<string[]>;
    /**
     * Returns the current instance. Syntactic sugar to make your code more fluent.
     * @returns this
     */
    get return(): AbstractSearch<TEntity>;
    /**
     * Alias for {@link Search.min}.
     */
    returnMin(field: string): Promise<TEntity | null>;
    /**
     * Alias for {@link Search.minId}.
     */
    returnMinId(field: string): Promise<string | null>;
    /**
     * Alias for {@link Search.minKey}.
     */
    returnMinKey(field: string): Promise<string | null>;
    /**
     * Alias for {@link Search.max}.
     */
    returnMax(field: string): Promise<TEntity | null>;
    /**
     * Alias for {@link Search.maxId}.
     */
    returnMaxId(field: string): Promise<string | null>;
    /**
     * Alias for {@link Search.maxKey}.
     */
    returnMaxKey(field: string): Promise<string | null>;
    /**
     * Alias for {@link Search.count}.
     */
    returnCount(): Promise<number>;
    /**
     * Alias for {@link Search.page}.
     */
    returnPage(offset: number, count: number): Promise<TEntity[]>;
    /**
     * Alias for {@link Search.pageOfIds}.
     */
    returnPageOfIds(offset: number, count: number): Promise<string[]>;
    /**
     * Alias for {@link Search.pageOrKeys}.
     */
    returnPageOfKeys(offset: number, count: number): Promise<string[]>;
    /**
     * Alias for {@link Search.first}.
     */
    returnFirst(): Promise<TEntity | null>;
    /**
     * Alias for {@link Search.firstId}.
     */
    returnFirstId(): Promise<string | null>;
    /**
     * Alias for {@link Search.firstKey}.
     */
    returnFirstKey(): Promise<string | null>;
    /**
     * Alias for {@link Search.all}.
     */
    returnAll(options?: {
        pageSize: number;
    }): Promise<TEntity[]>;
    /**
     * Alias for {@link Search.allIds}.
     */
    returnAllIds(options?: {
        pageSize: number;
    }): Promise<string[]>;
    /**
     * Alias for {@link Search.allKeys}.
     */
    returnAllKeys(options?: {
        pageSize: number;
    }): Promise<string[]>;
    private callSearch;
    private keysToEntityIds;
    private keyToEntityId;
}
/**
 * Entry point to raw search which allows using raw RediSearch queries
 * against Redis OM. Requires that RediSearch (and optionally RedisJSON) be
 * installed.
 * @template TEntity The type of {@link Entity} being sought.
 */
export declare class RawSearch<TEntity extends Entity> extends AbstractSearch<TEntity> {
    private rawQuery;
    /** @internal */
    constructor(schema: Schema<TEntity>, client: Client, query?: string);
    /** @internal */
    get query(): string;
}
/**
 * Entry point to fluent search. This is the default Redis OM experience.
 * Requires that RediSearch (and optionally RedisJSON) be installed.
 * @template TEntity The type of {@link Entity} being sought.
 */
export declare class Search<TEntity extends Entity> extends AbstractSearch<TEntity> {
    private rootWhere?;
    /** @internal */
    get query(): string;
    /**
     * Sets up a query matching a particular field. If there are multiple calls
     * to {@link Search.where}, they are treated logically as AND.
     * @param field The field to filter on.
     * @returns A subclass of {@link WhereField} matching the type of the field.
     */
    where(field: string): WhereField<TEntity>;
    /**
     * Sets up a nested search. If there are multiple calls to {@link Search.where},
     * they are treated logically as AND.
     * @param subSearchFn A function that takes a {@link Search} and returns another {@link Search}.
     * @returns `this`.
     */
    where(subSearchFn: SubSearchFunction<TEntity>): Search<TEntity>;
    /**
     * Sets up a query matching a particular field as a logical AND.
     * @param field The field to filter on.
     * @returns A subclass of {@link WhereField} matching the type of the field.
     */
    and(field: string): WhereField<TEntity>;
    /**
     * Sets up a nested search as a logical AND.
     * @param subSearchFn A function that takes a {@link Search} and returns another {@link Search}.
     * @returns `this`.
     */
    and(subSearchFn: SubSearchFunction<TEntity>): Search<TEntity>;
    /**
     * Sets up a query matching a particular field as a logical OR.
     * @param field The field to filter on.
     * @returns A subclass of {@link WhereField} matching the type of the field.
     */
    or(field: string): WhereField<TEntity>;
    /**
     * Sets up a nested search as a logical OR.
     * @param subSearchFn A function that takes a {@link Search} and returns another {@link Search}.
     * @returns `this`.
     */
    or(subSearchFn: SubSearchFunction<TEntity>): Search<TEntity>;
    private anyWhere;
    private anyWhereForField;
    private anyWhereForFunction;
    private createWhere;
}
