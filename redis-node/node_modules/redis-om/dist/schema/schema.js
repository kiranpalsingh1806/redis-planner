"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const crypto_1 = require("crypto");
const ulid_1 = require("ulid");
const json_schema_builder_1 = tslib_1.__importDefault(require("./builders/json-schema-builder"));
const hash_schema_builder_1 = tslib_1.__importDefault(require("./builders/hash-schema-builder"));
/**
 * Defines a schema that determines how an {@link Entity} is mapped to Redis
 * data structures. Construct by passing in an {@link EntityConstructor},
 * a {@link SchemaDefinition}, and optionally {@link SchemaOptions}:
 *
 * ```typescript
 * const schema = new Schema(Foo, {
 *   aString: { type: 'string' },
 *   aNumber: { type: 'number' },
 *   aBoolean: { type: 'boolean' },
 *   someText: { type: 'text' },
 *   aPoint: { type: 'point' },
 *   aDate: { type: 'date' },
 *   someStrings: { type: 'string[]' }
 * }, {
 *   dataStructure: 'HASH'
 * });
 * ```
 *
 * A Schema is primarily used by a {@link Repository} which requires a Schema in
 * its constructor.
 *
 * @template TEntity The {@link Entity} this Schema defines.
 */
class Schema {
    /**
     * The provided {@link EntityConstructor}.
     * @internal
     */
    entityCtor;
    /**
     * The provided {@link SchemaDefinition}.
     * @internal
     */
    definition;
    options;
    /**
     * @template TEntity The {@link Entity} this Schema defines.
     * @param ctor A constructor that creates an {@link Entity} of type TEntity.
     * @param schemaDef Defines all of the fields for the Schema and how they are mapped to Redis.
     * @param options Additional options for this Schema.
     */
    constructor(ctor, schemaDef, options) {
        this.entityCtor = ctor;
        this.definition = schemaDef;
        this.options = options;
        this.validateOptions();
        this.defineProperties();
    }
    /** The configured keyspace prefix in Redis for this Schema. */
    get prefix() { return this.options?.prefix ?? this.entityCtor.name; }
    /** The configured name for the RediSearch index for this Schema. */
    get indexName() { return this.options?.indexName ?? `${this.prefix}:index`; }
    /** The configured name for the RediSearch index hash for this Schema. */
    get indexHashName() { return this.options?.indexHashName ?? `${this.prefix}:index:hash`; }
    /**
     * The configured data structure, a string with the value of either `HASH` or `JSON`,
     * that this Schema uses to store {@link Entity | Entities} in Redis.
     * */
    get dataStructure() { return this.options?.dataStructure ?? 'JSON'; }
    /**
     * The configured usage of stop words, a string with the value of either `OFF`, `DEFAULT`,
     * or `CUSTOM`. See {@link SchemaOptions.useStopWords} and {@link SchemaOptions.stopWords}
     * for more details.
     */
    get useStopWords() { return this.options?.useStopWords ?? 'DEFAULT'; }
    /**
     * The configured stop words. Ignored if {@link Schema.useStopWords} is anything other
     * than `CUSTOM`.
     */
    get stopWords() { return this.options?.stopWords ?? []; }
    /**
     * The configured indexed default setting for fields
     */
    get indexedDefault() { return this.options?.indexedDefault ?? true; }
    /** The hash value of this index. Stored in Redis under {@link Schema.indexHashName}. */
    get indexHash() {
        const data = JSON.stringify({
            definition: this.definition,
            prefix: this.prefix,
            indexName: this.indexName,
            indexHashName: this.indexHashName,
            dataStructure: this.dataStructure,
            useStopWords: this.useStopWords,
            stopWords: this.stopWords,
        });
        return (0, crypto_1.createHash)('sha1').update(data).digest('base64');
    }
    /** @internal */
    get redisSchema() {
        if (this.dataStructure === 'HASH')
            return new hash_schema_builder_1.default(this).redisSchema;
        if (this.dataStructure === 'JSON')
            return new json_schema_builder_1.default(this).redisSchema;
        throw new Error(`'${this.dataStructure}' in an invalid data structure. Valid data structures are 'HASH' and 'JSON'.`);
    }
    /**
     * Generates a unique string using the configured {@link IdStrategy}.
     * @returns
     */
    generateId() {
        const ulidStrategy = () => (0, ulid_1.ulid)();
        return (this.options?.idStrategy ?? ulidStrategy)();
    }
    defineProperties() {
        Object.keys(this.definition).forEach(fieldName => {
            const fieldDef = this.definition[fieldName];
            const fieldAlias = fieldDef.alias ?? fieldName;
            this.validateFieldDef(fieldName, fieldDef);
            Object.defineProperty(this.entityCtor.prototype, fieldName, {
                configurable: true,
                get: function () {
                    return this.entityFields[fieldAlias].value;
                },
                set: function (value) {
                    this.entityFields[fieldAlias].value = value;
                }
            });
        });
    }
    validateOptions() {
        if (!['HASH', 'JSON'].includes(this.dataStructure))
            throw Error(`'${this.dataStructure}' in an invalid data structure. Valid data structures are 'HASH' and 'JSON'.`);
        if (!['OFF', 'DEFAULT', 'CUSTOM'].includes(this.useStopWords))
            throw Error(`'${this.useStopWords}' in an invalid value for stop words. Valid values are 'OFF', 'DEFAULT', and 'CUSTOM'.`);
        if (this.options?.idStrategy && !(this.options.idStrategy instanceof Function))
            throw Error("ID strategy must be a function that takes no arguments and returns a string.");
        if (this.prefix === '')
            throw Error(`Prefix must be a non-empty string.`);
        if (this.indexName === '')
            throw Error(`Index name must be a non-empty string.`);
    }
    validateFieldDef(field, fieldDef) {
        if (!['boolean', 'date', 'number', 'point', 'string', 'string[]', 'text'].includes(fieldDef.type))
            throw Error(`The field '${field}' is configured with a type of '${fieldDef.type}'. Valid types include 'boolean', 'date', 'number', 'point', 'string', 'string[]', and 'text'.`);
    }
}
exports.default = Schema;
