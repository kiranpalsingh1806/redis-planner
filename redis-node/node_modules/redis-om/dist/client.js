"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const redis_shim_1 = tslib_1.__importDefault(require("./shims/redis-shim"));
const repository_1 = require("./repository/repository");
const errors_1 = tslib_1.__importDefault(require("./errors"));
/**
 * A Client is the starting point for working with Redis OM. Clients manage the
 * connection to Redis and provide limited functionality for executing Redis commands.
 * Create a client and open it before you use it:
 *
 * ```typescript
 * const client = new Client();
 * await client.open();
 * ```
 *
 * A Client is primarily used by a {@link Repository} which requires a client in
 * its constructor.
 */
class Client {
    /** @internal */
    shim;
    /**
     * Attaches an existing Node Redis connection to this Redis OM client. Closes
     * any existing connection.
     * @param connection An existing Node Redis client.
     * @returns This {@link Client} instance.
     */
    async use(connection) {
        await this.close();
        this.shim = new redis_shim_1.default(connection);
        return this;
    }
    /**
     * Open a connection to Redis at the provided URL.
     * @param url A URL to Redis as defined with the [IANA](https://www.iana.org/assignments/uri-schemes/prov/redis).
     * @returns This {@link Client} instance.
     */
    async open(url = 'redis://localhost:6379') {
        if (!this.isOpen()) {
            this.shim = new redis_shim_1.default(url);
            await this.shim.open();
        }
        return this;
    }
    /**
     * Execute an arbitrary Redis command.
     * @template TResult Expect result type such as `string`, `Array<string>`, or whatever complex type Redis returns.
     * @param command The command to execute.
     * @returns The raw results of calling the Redis command.
     */
    async execute(command) {
        this.validateShimOpen();
        return await this.shim.execute(command.map(arg => {
            if (arg === false)
                return '0';
            if (arg === true)
                return '1';
            return arg.toString();
        }));
    }
    /**
     * Creates a repository for the given schema.
     * @template TEntity The entity type for this {@link Schema} and {@link Repository}.
     * @param schema The schema.
     * @returns A repository for the provided schema.
     */
    fetchRepository(schema) {
        this.validateShimOpen();
        if (schema.dataStructure === 'JSON') {
            return new repository_1.JsonRepository(schema, this);
        }
        else {
            return new repository_1.HashRepository(schema, this);
        }
    }
    /**
     * Close the connection to Redis.
     */
    async close() {
        await this.shim?.close();
        this.shim = undefined;
    }
    /** @internal */
    async createIndex(options) {
        this.validateShimOpen();
        const { indexName, dataStructure, prefix, schema, stopWords } = options;
        const command = [
            'FT.CREATE', indexName,
            'ON', dataStructure,
            'PREFIX', '1', `${prefix}`
        ];
        if (stopWords !== undefined)
            command.push('STOPWORDS', `${stopWords.length}`, ...stopWords);
        command.push('SCHEMA', ...schema);
        await this.shim.execute(command);
    }
    /** @internal */
    async dropIndex(indexName) {
        this.validateShimOpen();
        await this.shim.execute(['FT.DROPINDEX', indexName]);
    }
    /** @internal */
    async search(options) {
        this.validateShimOpen();
        const { indexName, query, limit, sort, keysOnly } = options;
        const command = ['FT.SEARCH', indexName, query];
        if (limit !== undefined)
            command.push('LIMIT', limit.offset.toString(), limit.count.toString());
        if (sort !== undefined)
            command.push('SORTBY', sort.field, sort.order);
        if (keysOnly)
            command.push('RETURN', '0');
        return await this.shim.execute(command);
    }
    /** @internal */
    async unlink(...keys) {
        this.validateShimOpen();
        if (keys.length > 0)
            await this.shim.unlink(keys);
    }
    /** @internal */
    async expire(key, ttl) {
        this.validateShimOpen();
        await this.shim?.expire(key, ttl);
    }
    /** @internal */
    async get(key) {
        this.validateShimOpen();
        return await this.shim.get(key);
    }
    /** @internal */
    async set(key, value) {
        this.validateShimOpen();
        await this.shim.set(key, value);
    }
    /** @internal */
    async hgetall(key) {
        this.validateShimOpen();
        return await this.shim.hgetall(key);
    }
    /** @internal */
    async hsetall(key, data) {
        this.validateShimOpen();
        await this.shim.hsetall(key, data);
    }
    /** @internal */
    async jsonget(key) {
        this.validateShimOpen();
        const json = await this.shim.execute(['JSON.GET', key, '.']);
        return JSON.parse(json);
    }
    /** @internal */
    async jsonset(key, data) {
        this.validateShimOpen();
        const json = JSON.stringify(data);
        await this.shim.execute(['JSON.SET', key, '.', json]);
    }
    /**
     * @returns Whether a connection is already open.
     */
    isOpen() {
        return !!this.shim;
    }
    validateShimOpen() {
        if (!this.shim)
            throw new errors_1.default("Redis connection needs to be open.");
    }
}
exports.default = Client;
