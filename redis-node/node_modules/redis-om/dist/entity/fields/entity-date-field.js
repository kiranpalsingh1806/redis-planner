"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const entity_field_1 = tslib_1.__importDefault(require("./entity-field"));
class EntityDateField extends entity_field_1.default {
    toRedisJson() {
        const data = {};
        if (this.value !== null)
            data[this.name] = this.valueAsNumber;
        return data;
    }
    fromRedisJson(value) {
        if (this.isNumber(value) || value === null)
            this.value = value;
        else
            throw Error(`Non-numeric value of '${value}' read from Redis for date field.`);
    }
    toRedisHash() {
        const data = {};
        if (this.value !== null)
            data[this.name] = this.valueAsNumber.toString();
        return data;
    }
    fromRedisHash(value) {
        const parsed = Number.parseFloat(value);
        if (Number.isNaN(parsed))
            throw Error(`Non-numeric value of '${value}' read from Redis for date field.`);
        const date = new Date();
        date.setTime(parsed * 1000);
        this.value = date;
    }
    validateValue(value) {
        super.validateValue(value);
        if (value !== null && !this.isDateable(value))
            throw Error(`Expected value with type of 'date' but received '${value}'.`);
    }
    convertValue(value) {
        if (this.isString(value)) {
            return new Date(value);
        }
        if (this.isNumber(value)) {
            const newValue = new Date();
            newValue.setTime(value * 1000);
            return newValue;
        }
        return super.convertValue(value);
    }
    isDateable(value) {
        return this.isDate(value) || this.isNumber(value) || this.isString(value);
    }
    isDate(value) {
        return value instanceof Date;
    }
    get valueAsNumber() {
        return this.value.getTime() / 1000;
    }
}
exports.default = EntityDateField;
